// Code is generated by the Amethyst.PacketGenerator (v1.0.5.0) tool.
// Do not edit this file manually.
#pragma warning disable CA1051

using Amethyst.Network.Engine.Packets;
using Amethyst.Network.Structures;
using Amethyst.Network.Utilities;

namespace Amethyst.Network.Packets;

public sealed class ProjectileUpdatePacket : IPacket<ProjectileUpdate>
{
    public int PacketID => 27;

    public static ProjectileUpdate Deserialize(ReadOnlySpan<byte> data, int offset = 0)
    {
        FastPacketReader reader = new(data, offset);

        short projectileIdx = reader.ReadInt16();
        NetVector2 position = reader.ReadNetVector2();
        NetVector2 velocity = reader.ReadNetVector2();
        byte ownerID = reader.ReadByte();
        short projectileType = reader.ReadInt16();
        NetBitsByte bitsByte1 = reader.ReadByte();
        NetBitsByte bitsByte2 = (byte)(bitsByte1[2] ? reader.ReadByte() : 0);
        float[] ai = new float[3];
        ai[0] = bitsByte1[0] ? reader.ReadSingle() : 0f;
        ai[1] = bitsByte1[1] ? reader.ReadSingle() : 0f;
        ushort bannerId = (ushort)(bitsByte1[3] ? reader.ReadUInt16() : 0);
        short damage = (short)(bitsByte1[4] ? reader.ReadInt16() : 0);
        float knockBack = bitsByte1[5] ? reader.ReadSingle() : 0f;
        short originalDamage = (short)(bitsByte1[6] ? reader.ReadInt16() : 0);
        short projUuid = (short)(bitsByte1[7] ? reader.ReadInt16() : -1);
        if (projUuid >= 1000)
        {
            projUuid = -1;
        }
        ai[2] = bitsByte2[0] ? reader.ReadSingle() : 0f;

        return new ProjectileUpdate
        {
            ProjectileIdentity = projectileIdx,
            Position = position,
            Velocity = velocity,
            OwnerID = ownerID,
            ProjectileType = projectileType,
            AI = ai,
            BannerId = bannerId,
            Damage = damage,
            KnockBack = knockBack,
            OriginalDamage = originalDamage,
            ProjectileUUID = projUuid
        };
    }

    public static byte[] Serialize(ProjectileUpdate packet)
    {
        FastPacketWriter writer = new(27, 128);

        writer.WriteInt16(packet.ProjectileIdentity);
        writer.WriteNetVector2(packet.Position);
        writer.WriteNetVector2(packet.Velocity);
        writer.WriteByte((byte)packet.OwnerID);
        writer.WriteInt16(packet.ProjectileType);
        NetBitsByte bitsByte1 = new();
        NetBitsByte bitsByte2 = new();
        bitsByte1[0] = packet.AI[0] != 0f;
        bitsByte1[1] = packet.AI[1] != 0f;
        bitsByte2[0] = packet.AI[2] != 0f;
        if (packet.BannerId != 0)
        {
            bitsByte1[3] = true;
        }
        if (packet.Damage != 0)
        {
            bitsByte1[4] = true;
        }
        if (packet.KnockBack != 0f)
        {
            bitsByte1[5] = true;
        }
        if (packet.ProjectileType > 0 && packet.ProjectileUUID != -1)
        {
            bitsByte1[7] = true;
        }
        if (packet.OriginalDamage != 0)
        {
            bitsByte1[6] = true;
        }
        if (bitsByte2[0])
        {
            bitsByte1[2] = true;
        }
        writer.WriteByte((byte)bitsByte1);
        if (bitsByte1[2])
        {
            writer.WriteByte((byte)bitsByte2);
        }
        if (bitsByte1[0])
        {
            writer.WriteSingle(packet.AI[0]);
        }
        if (bitsByte1[1])
        {
            writer.WriteSingle(packet.AI[1]);
        }
        if (bitsByte1[3])
        {
            writer.WriteUInt16((ushort)packet.BannerId);
        }
        if (bitsByte1[4])
        {
            writer.WriteInt16((short)packet.Damage);
        }
        if (bitsByte1[5])
        {
            writer.WriteSingle(packet.KnockBack);
        }
        if (bitsByte1[6])
        {
            writer.WriteInt16((short)packet.OriginalDamage);
        }
        if (bitsByte1[7])
        {
            writer.WriteInt16((short)packet.ProjectileUUID);
        }
        if (bitsByte2[0])
        {
            writer.WriteSingle(packet.AI[2]);
        }

        return writer.Build();
    }
}

public struct ProjectileUpdate
{
    /// <summary>
    /// Projectile identity. Not index.
    /// </summary>
    public short ProjectileIdentity;
    public NetVector2 Position;
    public NetVector2 Velocity;
    public byte OwnerID;
    public short ProjectileType;
    public float[] AI;
    public int BannerId;
    public int Damage;
    public float KnockBack;
    public int OriginalDamage;
    public int ProjectileUUID;
}
