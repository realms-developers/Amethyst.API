// Code is generated by the Amethyst.PacketGenerator (v1.0.5.0) tool.
// Do not edit this file manually.
#pragma warning disable CA1051

using Amethyst.Server.Network.Core.Packets;
using Amethyst.Server.Network.Utilities;

namespace Amethyst.Server.Network.Packets;

public sealed class ItemPatchPacket : IPacket<ItemPatch>
{
    public int PacketID => 88;

    public ItemPatch Deserialize(ReadOnlySpan<byte> data, int offset = 0)
    {
        FastPacketReader reader = new(data, offset);

        short ItemIndex = reader.ReadInt16();
        byte Flags = reader.ReadByte();
        ulong? ItemColor = reader.ReadUNKNOWN();
        ushort? ItemDamage = reader.ReadUNKNOWN();
        float? ItemKnockback = reader.ReadUNKNOWN();
        ushort? UseAnimation = reader.ReadUNKNOWN();
        ushort? UseTime = reader.ReadUNKNOWN();
        short? Shoot = reader.ReadUNKNOWN();
        float? ShootSpeed = reader.ReadUNKNOWN();
        short? ItemWidth = reader.ReadUNKNOWN();
        short? ItemHeight = reader.ReadUNKNOWN();
        float? ItemScale = reader.ReadUNKNOWN();
        short? Ammo = reader.ReadUNKNOWN();
        short? UseAmmo = reader.ReadUNKNOWN();
        bool? NotAmmo = reader.ReadUNKNOWN();

        return new ItemPatch
        {
            ItemIndex = ItemIndex,
            Flags = Flags,
            ItemColor = ItemColor,
            ItemDamage = ItemDamage,
            ItemKnockback = ItemKnockback,
            UseAnimation = UseAnimation,
            UseTime = UseTime,
            Shoot = Shoot,
            ShootSpeed = ShootSpeed,
            ItemWidth = ItemWidth,
            ItemHeight = ItemHeight,
            ItemScale = ItemScale,
            Ammo = Ammo,
            UseAmmo = UseAmmo,
            NotAmmo = NotAmmo,
        };
    }

    public byte[] Serialize(ItemPatch packet)
    {
        FastPacketWriter writer = new(88, 128);

        writer.WriteInt16(packet.ItemIndex);
        writer.WriteByte(packet.Flags);
        writer.WriteUNKNOWN(packet.ItemColor);
        writer.WriteUNKNOWN(packet.ItemDamage);
        writer.WriteUNKNOWN(packet.ItemKnockback);
        writer.WriteUNKNOWN(packet.UseAnimation);
        writer.WriteUNKNOWN(packet.UseTime);
        writer.WriteUNKNOWN(packet.Shoot);
        writer.WriteUNKNOWN(packet.ShootSpeed);
        writer.WriteUNKNOWN(packet.ItemWidth);
        writer.WriteUNKNOWN(packet.ItemHeight);
        writer.WriteUNKNOWN(packet.ItemScale);
        writer.WriteUNKNOWN(packet.Ammo);
        writer.WriteUNKNOWN(packet.UseAmmo);
        writer.WriteUNKNOWN(packet.NotAmmo);

        return writer.BuildPacket();
    }
}

public struct ItemPatch
{
    public short ItemIndex;
    public byte Flags;
    public ulong? ItemColor;
    public ushort? ItemDamage;
    public float? ItemKnockback;
    public ushort? UseAnimation;
    public ushort? UseTime;
    public short? Shoot;
    public float? ShootSpeed;
    public short? ItemWidth;
    public short? ItemHeight;
    public float? ItemScale;
    public short? Ammo;
    public short? UseAmmo;
    public bool? NotAmmo;
}